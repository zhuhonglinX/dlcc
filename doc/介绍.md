

# dlcc - 简单 C 语言编译器
> doc 所有内容都会显得比较啰嗦，因为这些文档的内容我打算填充到论文里（毕竟论文有字数要求）

毕业设计的课题：简单 C 语言编译器的设计与实现

dlcc 实现了简单类 C 的语法，使用 C++ 11 来实现，开发平台 Ubuntu 16.04



dlcc 输入单个 C 语言源文件，可以根据用户需求，可以输出：

* 输出汇编文件
* 直接执行 C 程序。

输出的汇编代码为 AT&T 格式的 32 位的汇编代码，因此可以同时支持 Linux 平台 32 位机和 64 位机。



## dlcc 简介及使用

使用 cmake 构建项目，cmake 是 广泛用于 C++ 工程的构建工具，通过他，我们可以生成不同机器平台的 Makefile 文件，从而简化了程序的构建过程。对于构建工具会在实现阶段具体介绍。现在主要关注使用即可。

首先明确目录结构，设定 dlcc 的工程目录名为 `mycompiler`。该目录下存放所有的 dlcc 的代码源文件和二进制文件。我规定 dlcc 的二进制文件必须存放在 `build` 目录中，规定测试代码必须放入 `test` 目录中。

所以首先进入工程目录，创建 build 目录。接着进入 build 目录，执行构建命令。指令如下：

```shell
mkdir build
cd build
cmake ..
make
```

会在 build 下生成 dlcc 可执行文件。接下去就可以使用 dlcc 了。

dlcc 本身可接受参数：

- -i，解释器模式，立刻执行
- -s，汇编器模式，产生汇编代码
- -o，指明生成的汇编代码输出文件

默认 test 目录中已经有部分测试文件，测试文件涵盖 C 基本语句，包括简单赋值、调用 C 库函数（printf）、条件分支、循环语句、函数调用、递归等支持。因此可以直接使用这些测试文件，观察 dlcc 执行过程。使用 dlcc 的例子如下：

```shell
./dlcc ../test/a.c -i
./dlcc ../test/a.c -s -o ../test/a.s
```

也可以将 dlcc 直接添加到环境变量（path） 中，比如你是使用 zsh 终端：

```shell
vim ~/.zshrc
```

在该文件中添加如下语句，注意填充自己的项目路径

```shell
# dlcc
export PATH=<your project path>/build:$PATH 
```

之后就可以直接使用了，本文之后所有的内容中都默认已经添加 dlcc 到 path



#### 为什么终端出现很多输出

这些输出均为调试信息，目的是为了方便在开发中更快的定位程序的错误，开发完毕后仍然可以通过这些输出，观察 dlcc 的每一个模块执行的过程。在源代码中，我开启了`DEBUG`宏，如下：

```c
#define DEBUG
```

所有的终端调试输出，均使用这种方式实现：

```c
#ifdef DEBUG
// 调试信息
#endif
```

所以如果不需要调试信息，只需要将`#define DEBUG`这一句话注释即可。



#### 为什么使用 C++ 11

编译器需要被编译成目标平台的可执行文件，这样才可以在命令行输入：

```shell
dlcc ...
```

因此我必须选择可以方便编译成目标平台的语言来完成。虽然在开发角度来说，选择 Java 和 Python 开发对我来说会很方便，但是用这两个语言写的程序转换成目标机器的二进制，会有不小的坑。

C++ 11 其实语法已经很现代化了，相比于 C 来说支持了很多容器和新式语法，写起来更方便。同时相比于 Go、Rust 等同样目标代码是二进制文件的语言来说，C++ 11 有更成熟的开发环境支持，更高的执行效率，语法我也更熟悉。因此最终选择 C++ 11 来实现 dlcc 编译器。



#### 执行汇编代码

dlcc 输出的汇编代码是 AT&T 风格的。关于汇编这一部分会在之后比较仔细的介绍一下。现在只要关心怎么把汇编代码转换成可执行文件就行了。

> 流程图 :《汇编文件》 ==> 汇编器 ==> 《二进制代码》==> 链接器 ==> 可执行文件 

这里就要用到汇编器（Assemble）和链接器（Linker），我直接使用 Linux 操作系统自带的汇编器和链接器。

先生成汇编文件：

```shell
dlcc ./a.c -s -o ./a.s
```

生成名为 a.s 的汇编文件。然后使用 gas 汇编器和 ld 链接器

```shell
as --32 a.s -o a.o
ld -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -lc a.o -o a
./a
```

这样就可以直接执行了，当然 linux 本机都是自带 gcc 的，也可以使用 gcc 快速生成可执行文件

```shell
gcc -m32 a.s -o a
./a
```

这个 a 文件是目标平台的可执行文件，本文实验平台是 Ubuntu 16.04 x86_64，因此在任意一台同样体系结构的计算机上都可以直接执行。