# dlcc 简单 C 语言编译器设计

## 编译器总体设计

编译器究竟完成了什么工作？如果你认真去探究编译究竟是什么意思，会发现通常人们说的编译器，其实往往是指广义的编译器，广义的编译器就是指从源代码程序输入开始，直到产生可执行程序或者直接输出结果，如下图，举例了一般编译器的工作流程。

> 一般编译器工作流程图：预处理 编译 汇编 链接

如果仔细体会编译这个过程，很容易发现编译就像是翻译。编译器就好像翻译员，他的作用在于将某种程序的源程序语言，翻译成计算机可以处理的目标语言，这个目标语言可以有很多种，比如汇编语言代码，比如二进制文件，甚至是目标机器的可执行二进制代码。

当然现实场景中，还有另一种模式的编译器，一般称为解释器，如 Python、Ruby 等，都是用了解释的技术，这些语言往往是将源代码程序转换成自身定义的虚拟指令，最终使用内置的虚拟机解释执行，直接产生结果。在这里，虚拟指令，也可以看做是一种目标语言。

这样看来，编译器所指的范围变得广义化了。dlcc 编译器希望能够结合这两者，既能产生汇编文件，也可以使用程序内置的虚拟机直接执行代码。如图:

> dlcc 工作流程图

dlcc 能够接收类 C 语言源文件（C-like source file），然后根据用户需要，产生两种不同的输出：

* 输出汇编代码，并根据用户指定的文件名，将汇编代码存储到目标文件，通常用 .s 结尾表示汇编文件。
* 产生虚拟指令，并使用内置虚拟机直接执行出结果。

## 模块设计

根据总体设计，将编译器分为以下几个模块

* 词法分析器
* 语法分析器
* 语义分析
* 代码生成器
* 抽象语法树
* 符号表和作用域模块

各模块之间工作流程如下图：

> 图：模块之间工作流程图

### 词法分析设计

词法分析（lexical analysis）模块工作示意图：

> 词法分析工作示意图

如果需要写一个程序，人们首先会在编辑器（Editor）中写下某种语言的源文件（source file），并将其保存在磁盘上。词法分析器所需要的输入就是这样的字符文件，或者说字符流（stream）。

我最终的目的是要将字符流转换为计算机可以理解的目标代码并输出，不过词法分析器不需要做那么多，他的任务是输出 Token 流。

Token 是对某种语言可识别的字符组合的代称，这个字符组可以是单个字符，也可以是多个字符组合。例如：

```c
while
abc
;
//
```

C 语言中，会存在一些关键词（Keyword），比如上述的 while 关键词，这个关键词是多个字符组成的，但是对于编译器来说，首先要做的就是将 while 看成一个整体，而不是看成五个单个的英文字母。

同理，例如 abc，根据 C 语言的语法，这应当看做一个变量的名字或者函数的名字，总而言之 abc 应当被编译器视为一个整体，而不是三个字母，通常把这类字符组合称为标识符（Identifier）。第三个例子，是单字符分号（Semicolon），即使分号是单个字符，但是根据 C 的语法，分号作为语句（Statement）的结束，也应当视作一个单独的字符组合。

以上每一个字符组合都应当视作一个单独的 Token。由此可以明确，词法分析器的任务，是将包含许多字符的字符流，解析成一个个 Token，所有的 Token 合起来，称为 Token 流。



### 语法分析设计

语法分析（Parse）的目的，是将 Token 流转换成计算机十分容易理解的形式。因此，词法分析的输入是 Token 流，输出是某种形式。通常，所谓计算机容易理解的形式或者结构，就是抽象语法树（Abstract Syntax Tree）结构。为什么语法树易于理解，可以简单举一个例子：

```c
a = b + c;
```

改写成语法树：

> 图

这种结构之所以称为易于计算机理解的结构，原因很简单，你可以使用一个通用的算法，使得这个表达式能被计算机分步骤执行，并且不产生歧义，也不会出现逻辑顺序错误，比如我可以在这里使用二叉树的后序遍历算法（Post-Order Traversal Algorithm）。这样程序会先执行`b + c`，将结果保存在`temp`中，然后向上传递，接着自然执行`a = temp`，如此就完成了整个语句，并且将 a 的值改写为 b 与 c 的和，这与我们数学课上学的的计算逻辑是一致的。

其中 temp 是一个暂时的变量（Variable），我通常使用这个符号表示这个变量只是暂时存储数据。当语句十分复杂的时候，可能需要多个 temp 临时变量来存储多个中间数据，这时候可以使用栈（Stack）这种结构来解决这个问题。这个问题不需在语法分析阶段关心，在之后的代码生成器会解决这个问题。

总之抽象语法树就是语法分析器的输出，这个也是实现语法分析器的根本目的。



### 语义分析设计

教科书的说法，语义分析（Semantic Analysis）需要去除掉抽象语法树的多余内容，并添加一些必要的信息。换一种说法，语义分析通过某种算法遍历语法分析构建的语法树，试图去理解这颗语法树究竟表达的是什么意思。包括变量究竟是不是存在，如果存在那么该变量在哪个作用域（Scope）。

例如这个语法分析树：

> 还是上面那个图

例如我此刻计算 `b + c`，首先需要判断变量 b 是否存在，这需要涉及符号表(Symbol Table)，由于最后要进行计算，因此必须明确 b 值是多少，当然语法分析不做计算，但是要知道 b 的值是多少，你必须确定这个 b 究竟是哪一个变量 b。比如我们都知道局部变量可以覆盖同名的全局变量，当出现如下情况：

```c
int c = 0;
int get_num() {
  int c = 1;
  return c;
}
```

很明显函数外部的 c 与函数内部的 c 是不同作用域的，语义分析需要判定这个变量是否已经被声明过，并且判定该变量究竟是哪一个作用域的变量。

从设计的角度讲， 语义分析应当同时和语法树，符号表和作用域模块相联系。语义分析对语法树进行至少一次遍历，获得语句的上下文信息，结合符号表和作用域的情况，分析出某个语句是否合法。如果合法，则明确语义动作。若不合法，则进行报错处理。



###  符号表和作用域设计

符号表（Symbol）的作用：存储变量的相关信息，如类型、数值。符号表能够为语义分析和代码生成提供必要的信息，如判断变量是否存在、存储变量的值、管理变量信息等作用。符号表需要设计变量符号表和函数符号表，由于  dlcc 不允许函数内部声明、实现函数。所以所有的函数都可以看做是属于顶级作用域的函数，因此函数符号表可以隐式，通过语法树直接分析就可以得到函数信息。

作用域（Scope）的作用如前文所述，一个变量不仅包含着自身所携带的信息，而且必须包含自身所处的环境信息，这个环境就是作用域。变量声明所处的位置，就是他的作用域范围。根据 C 语言的语法，每一个大括号范围内就是一个新的作用域，如下：

```c
int a = 10;
int main() {
  int b = 1;
  if (a > 0) {
    int c = a + b;
  }
  return 0;
}
```

其中顶级作用域就是全局变量，a 属于顶级作用域的变量。b 属于 main 函数作用域的变量，c 属于 if 语句块作用域的变量。并且不同的作用域应当具有包含关系，比如我可以在 if 语句块的作用域内调用顶级作用域的变量 a，这个是没有问题的，但是如果在 if 语句块之外使用变量 c，就会报错。这种关系说明作用域有包含的关系，次一级的作用域可以使用上级作用域的变量，如果变量名相同，则距离最近的作用域的变量会覆盖高一级作用域的变量。这种关系使用树（tree）这种结构可以很好地表达出来。



### 代码生成器设计

代码生成器分成两个部分：汇编代码生成器和虚拟指令生成器。

汇编代码生成器主要生成 32 位 AT&T 格式代码，并且目标操作系统是 Linux 32 位或 64 位操作系统。限定操作系统是因为不同操作系统汇编代码的格式会有不一致，我只能保证实验机器（Ubuntu 16.04）的汇编代码的可行和正确。32 位的汇编代码和 64 位同样不一样，但是 64 位机器可以支持运行 32 位的程序，因此 32 位的汇编代码既可以在 32 位机器上被汇编器编译，也可以在 64 位机器上称为汇编器的输入。生成的汇编语句借助栈结构存储数据，为了简化流程，只使用两个通用寄存器，配合栈进行各种运算。

虚拟指令生成器，首先需要设计虚拟指令，采用类似汇编的指令集，但是简化操作数。简化操作数的代价是增加指令集，但是虚拟指令增加指令集并不会增加多少开销，所以可以简化开发流程。



### 虚拟机设计

虚拟机（Virtual Machine）是专门接收虚拟指令，并对不同虚拟指令做出不同反应的模块。dlcc 的虚拟机模仿真实的机器运转方式。设置 pc，数据栈等数据结构，从而模拟类似 mov，push 等指令。



## 数据结构设计

### Token 数据结构

设计一个枚举类型，表示不同的字符组合，如部分关键字，标识符，特殊符号等。

### 抽象语法树数据结构

由于不同的语句具有不同的结构，因此抽象语法树的结构无法固定，最终借助了面向对象编程的继承和多态技术。构建了一个抽象的通用语法树，然后针对不同的语句，设置特定语句的语法树，并且继承通用语法树，并实现相关虚函数。然后通过通用语法树指针，即可抽象的表达不同语句的特定的语法树。

### 符号表结构

符号表结构需要依托作用域，因此对于每一个作用域都产生一个符号表。由于同一个作用域之内，不允许重名变量，因此完全可以使用类似 key - value 的模式，使用变量名字作为 key，变量的各种特征和存储数值作为一个整体，当成 value 处理。

### 作用域数据结构

作用域采用树类的结构，一个节点表示一个作用域。由于是一颗任意的树，所以整棵树使用孩子兄弟表示法表示。并且保证每一个抽象语法树节点都包含着一个作用域指针，代表该节点所属的作用域。